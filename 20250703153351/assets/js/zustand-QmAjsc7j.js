import{R as j}from"./react-In5IJgbb.js";const E=t=>{let n;const e=new Set,s=(d,a)=>{const v=typeof d=="function"?d(n):d;if(!Object.is(v,n)){const p=n;n=a??(typeof v!="object"||v===null)?v:Object.assign({},n,v),e.forEach(f=>f(n,p))}},r=()=>n,u={setState:s,getState:r,getInitialState:()=>S,subscribe:d=>(e.add(d),()=>e.delete(d))},S=n=t(s,r,u);return u},J=t=>t?E(t):E,D=t=>t;function M(t,n=D){const e=j.useSyncExternalStore(t.subscribe,()=>n(t.getState()),()=>n(t.getInitialState()));return j.useDebugValue(e),e}const T=t=>{const n=J(t),e=s=>M(n,s);return Object.assign(e,n),e},$=t=>t?T(t):T,R={},O=new Map,b=t=>{const n=O.get(t);return n?Object.fromEntries(Object.entries(n.stores).map(([e,s])=>[e,s.getState()])):{}},P=(t,n,e)=>{if(t===void 0)return{type:"untracked",connection:n.connect(e)};const s=O.get(e.name);if(s)return{type:"tracked",store:t,...s};const r={connection:n.connect(e),stores:{}};return O.set(e.name,r),{type:"tracked",store:t,...r}},F=(t,n={})=>(e,s,r)=>{const{enabled:i,anonymousActionType:h,store:u,...S}=n;let d;try{d=(i??(R?"production":void 0)!=="production")&&window.__REDUX_DEVTOOLS_EXTENSION__}catch{}if(!d)return t(e,s,r);const{connection:a,...v}=P(u,d,S);let p=!0;r.setState=(o,m,c)=>{const l=e(o,m);if(!p)return l;const y=c===void 0?{type:h||"anonymous"}:typeof c=="string"?{type:c}:c;return u===void 0?(a==null||a.send(y,s()),l):(a==null||a.send({...y,type:`${u}/${y.type}`},{...b(S.name),[u]:r.getState()}),l)};const f=(...o)=>{const m=p;p=!1,e(...o),p=m},g=t(r.setState,s,r);if(v.type==="untracked"?a==null||a.init(g):(v.stores[v.store]=r,a==null||a.init(Object.fromEntries(Object.entries(v.stores).map(([o,m])=>[o,o===v.store?g:m.getState()])))),r.dispatchFromDevtools&&typeof r.dispatch=="function"){let o=!1;const m=r.dispatch;r.dispatch=(...c)=>{(R?"production":void 0)!=="production"&&c[0].type==="__setState"&&!o&&(console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'),o=!0),m(...c)}}return a.subscribe(o=>{var m;switch(o.type){case"ACTION":if(typeof o.payload!="string"){console.error("[zustand devtools middleware] Unsupported action format");return}return I(o.payload,c=>{if(c.type==="__setState"){if(u===void 0){f(c.state);return}Object.keys(c.state).length!==1&&console.error(`
                    [zustand devtools middleware] Unsupported __setState action format.
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `);const l=c.state[u];if(l==null)return;JSON.stringify(r.getState())!==JSON.stringify(l)&&f(l);return}r.dispatchFromDevtools&&typeof r.dispatch=="function"&&r.dispatch(c)});case"DISPATCH":switch(o.payload.type){case"RESET":return f(g),u===void 0?a==null?void 0:a.init(r.getState()):a==null?void 0:a.init(b(S.name));case"COMMIT":if(u===void 0){a==null||a.init(r.getState());return}return a==null?void 0:a.init(b(S.name));case"ROLLBACK":return I(o.state,c=>{if(u===void 0){f(c),a==null||a.init(r.getState());return}f(c[u]),a==null||a.init(b(S.name))});case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return I(o.state,c=>{if(u===void 0){f(c);return}JSON.stringify(r.getState())!==JSON.stringify(c[u])&&f(c[u])});case"IMPORT_STATE":{const{nextLiftedState:c}=o.payload,l=(m=c.computedStates.slice(-1)[0])==null?void 0:m.state;if(!l)return;f(u===void 0?l:l[u]),a==null||a.send(null,c);return}case"PAUSE_RECORDING":return p=!p}return}}),g},A=F,I=(t,n)=>{let e;try{e=JSON.parse(t)}catch(s){console.error("[zustand devtools middleware] Could not parse the received json",s)}e!==void 0&&n(e)},W=(t,n)=>(...e)=>Object.assign({},t,n(...e));function H(t,n){let e;try{e=t()}catch{return}return{getItem:r=>{var i;const h=S=>S===null?null:JSON.parse(S,void 0),u=(i=e.getItem(r))!=null?i:null;return u instanceof Promise?u.then(h):h(u)},setItem:(r,i)=>e.setItem(r,JSON.stringify(i,void 0)),removeItem:r=>e.removeItem(r)}}const w=t=>n=>{try{const e=t(n);return e instanceof Promise?e:{then(s){return w(s)(e)},catch(s){return this}}}catch(e){return{then(s){return this},catch(s){return w(s)(e)}}}},U=(t,n)=>(e,s,r)=>{let i={storage:H(()=>localStorage),partialize:o=>o,version:0,merge:(o,m)=>({...m,...o}),...n},h=!1;const u=new Set,S=new Set;let d=i.storage;if(!d)return t((...o)=>{console.warn(`[zustand persist middleware] Unable to update item '${i.name}', the given storage is currently unavailable.`),e(...o)},s,r);const a=()=>{const o=i.partialize({...s()});return d.setItem(i.name,{state:o,version:i.version})},v=r.setState;r.setState=(o,m)=>{v(o,m),a()};const p=t((...o)=>{e(...o),a()},s,r);r.getInitialState=()=>p;let f;const g=()=>{var o,m;if(!d)return;h=!1,u.forEach(l=>{var y;return l((y=s())!=null?y:p)});const c=((m=i.onRehydrateStorage)==null?void 0:m.call(i,(o=s())!=null?o:p))||void 0;return w(d.getItem.bind(d))(i.name).then(l=>{if(l)if(typeof l.version=="number"&&l.version!==i.version){if(i.migrate){const y=i.migrate(l.state,l.version);return y instanceof Promise?y.then(_=>[!0,_]):[!0,y]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,l.state];return[!1,void 0]}).then(l=>{var y;const[_,k]=l;if(f=i.merge(k,(y=s())!=null?y:p),e(f,!0),_)return a()}).then(()=>{c==null||c(f,void 0),f=s(),h=!0,S.forEach(l=>l(f))}).catch(l=>{c==null||c(void 0,l)})};return r.persist={setOptions:o=>{i={...i,...o},o.storage&&(d=o.storage)},clearStorage:()=>{d==null||d.removeItem(i.name)},getOptions:()=>i,rehydrate:()=>g(),hasHydrated:()=>h,onHydrate:o=>(u.add(o),()=>{u.delete(o)}),onFinishHydration:o=>(S.add(o),()=>{S.delete(o)})},i.skipHydration||g(),f||p},X=U,C=t=>Symbol.iterator in t,x=t=>"entries"in t,N=(t,n)=>{const e=t instanceof Map?t:new Map(t.entries()),s=n instanceof Map?n:new Map(n.entries());if(e.size!==s.size)return!1;for(const[r,i]of e)if(!Object.is(i,s.get(r)))return!1;return!0},L=(t,n)=>{const e=t[Symbol.iterator](),s=n[Symbol.iterator]();let r=e.next(),i=s.next();for(;!r.done&&!i.done;){if(!Object.is(r.value,i.value))return!1;r=e.next(),i=s.next()}return!!r.done&&!!i.done};function G(t,n){return Object.is(t,n)?!0:typeof t!="object"||t===null||typeof n!="object"||n===null?!1:!C(t)||!C(n)?N({entries:()=>Object.entries(t)},{entries:()=>Object.entries(n)}):x(t)&&x(n)?N(t,n):L(t,n)}export{H as a,W as b,$ as c,A as d,X as p,G as s};
